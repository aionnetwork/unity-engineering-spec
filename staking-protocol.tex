\section{Staking and Stake Delegation Protocols}

The Unity consensus algorithm combines both proof of work (PoW) and proof of stake (PoS) \cite{WZS19}. This section of the specification outlines the implementation of the PoS subsystem in isolation, to simplify exposition. PoS requires system participants to \textit{stake} their Aion network tokens; we specify the mechanisms to perform \textit{staking}, and the implementation requirements on the core blockchain protocol \& ancillary user interfaces required to interact with the system. 

\subsection{Fixing Terminology}
In the PoS subsystem of Unity \cite{WZS19}, any coin holder of a system can run a full node in the blockchain network in order to produce PoS blocks; we refer to these coin holders as \textit{stakers}.

In order to support a staker's participation in PoS consensus, coins must be rendered immobile (i.e. they cannot be freely transferred to other users) via their submission into the staking system; these coins are referred to as \textbf{\textit{stake}}. As long as these coins are held (on behalf of the owner) in the staking system, they contribute to the total influence of the staker in the PoS consensus (as discussed in the Unity paper \cite{WZS19}). 

When a coin holder casts their coin as stake to a staker, we call this action a \textbf{\textit{vote}} or \textbf{\textit{bond}}. Notice that we  to use the word \say{stake} strictly as a noun throughout this document and the implementation; this is done to avoid confusion with the action of casting coins to a staker, for which we use the verbs \textit{to bond} and \textit{to vote} interchangeably. 

The coin holder can either vote for themselves (increasing their power as a staker in PoS) or they can vote for another staker. The action of voting for another staker is referred to as \textbf{\textit{delegation}}. We further discuss the motivation for delegation in \S\ref{delegation_overview}.

Any coin holder that votes for another staker (in order to earn a share of PoS block rewards in exchange for increasing the power of said staker in PoS) is referred to as a \textit{delegator}. Note that a delegator is not a staker, since they don't operate a node and contribute to PoS security.

At any point, a delegator or a voter can choose to withdraw their bonded coins (reducing the PoS power of the staker delegated or voted to). When a delegator withdraws their delegated coins, they are said to \textbf{\textit{undelegate}}. When a voter withdraw their voted coins, they are said to \textbf{\textit{unvote}} or \textbf{\textit{unbond}}. In either scenario, when the coins in question get unbonded in the staking system, they are subject to a post-lock period (\cite{WZS19} \S4.1.1). After the post-lock period has elapsed, their coins exit the staking system and become \textbf{\textit{liquid}} (free to transfer to other users). 

A delegator is allowed to \textbf{\textit{transfer}} their delegation between stakers (subject to stipulations discussed in a subsequent section). 

\subsubsection{The Need for Delegation} \label{delegation_overview}
In the PoW paradigm, mining pools allow participants with modest hash power to \textit{pool} their resources with strangers to achieve a more reliable outlay of rewards. Similarly, in PoS networks, \textit{delegation} allows users to transfer their rights to participate in the proof of stake (PoS) protocol to \textit{stake pools}. 

The rationale for stake-delegation is very much in-line with the rationale for hash-power-pooling: since PoW miners controlling small amounts of hash power are not expected to run a full node in order to write blocks on rare occasions, we should not expect stakers with small amount of stake to do so either. Furthermore, while miners are generally technically proficient and commit their time to maintaining on-premises infrastructure, owners of stake in the network might lack the expertise or time to do so. Even if one has the willingness to operate a staking node, one might have too little stake to cover operational costs. 

Delegation allows all coin holders of Aion to contribute to PoS security, regardless of the amount of coins they own, or their technical capabilities.

\subsection{Solution Synopsis}

\subsubsection{Staking Contract}
All logic related to staking will be implemented on an AVM smart contract called the \textit{staker registry contract}. In order to participate in staking, coin-holders must send Aion to this contract, where the balance will reside, until the user decides to \textit{unstake}. Upon unbonding, after a post-active period has elapsed, the balance will be returned by the staking contract to the user's address (see \cite{WZS19} \S4.1.1 and \S5 for rationale and further exposition). Note, that the pre-active period as defined in \cite{WZS19} \S4.1.1 will be zero (i.e. no pre-active stake locking).  

This contract is core to the system; correct functioning of the protocol (PoS) depends on the state of this contract, in that the life-cycle of all bonded coins are managed by this contract. 

\subsubsection{Delegation Protocol}
There exist a continuum of strategies to realize delegation in Aion, which can be characterized by the following extrema:
\begin{itemize}
    \item \textbf{Open}: No delegation features implemented in the core protocol (e.g. PoW, where hash-power-pooling is an off-protocol activity). In order to delegate stake, custodial staking pools would define their own payout schemes, user interfaces, fee-structures, etc. 
    \item \textbf{Opinionated}: The core protocol defines a rigid stake delegation protocol. Examples of such protocols include Cardano-Shelley \cite{KBC19} and Tezos \cite{Goo14}. This protocol would clearly define all stake delegation-related interactions between stakeholders and pools, like reward distribution schedule and fee structure.   
\end{itemize}

We take an approach that lies in-between the two extremes. In our approach, the delegation system is completely decoupled from the core protocol. The staking contract exposes a very simple interface to enable stake delegation (while maintaining security-related system invariants). This enables the development of arbitrary delegation protocols through the use of AVM smart contracts we will refer to as \textit{delegation contracts}; these contracts will primarily be responsible for distribution of rewards to delegators and managing the stake life-cycle, while it's delegated to a pool. Figure \ref{fig:delegation_scheme} offers a component-level sketch of how purported delegation contracts relate to the Staker Registry. 

\tikzset{
    block/.style = {draw, fill=white, rectangle, minimum height=3em, minimum width=3em},
    pinstyle/.style = {pin edge={to-,thin,black}}
}
\begin{figure}[ht]
\centering
\begin{tikzpicture}[auto,>=latex']
    \node [block, name=sc, align=center, minimum width=3.4cm] (sc) {Staker Registry\\Contract};
    \node [block, right of=sc, node distance=6.5cm, align=center, minimum width=3.6cm] (dc0) {Public\\Delegation Contract};
    \node [block, below of=dc0,node distance=2cm, align=center, dashed, minimum width=3.6cm] (dc1){Custom\\Delegtion Contract};
    \draw [<-] (sc) -- node{$calls$} (dc0);
    \draw [<-, dashed] (sc) -- node[pos=0.5]{$calls$} (dc1);
\end{tikzpicture}
\caption{Contracts implementing staking and delegation in Aion-Unity}
\label{fig:delegation_scheme}
\end{figure}

\paragraph{Public Delegation Protocol}
A key goal in Unity system-design is the engagement of all Aion coin-holders in staking. To serve that goal, we further specify an opinionated \textit{public delegation protocol} (implemented as a delegation contract) we call the \textbf{Aion Public Delegation Standard (ADS)}. The corresponding contract is called the \textit{ADS Pool Registry}. This Aion-Unity upgrade will be shipped with the ADS and all foundation-supported staking user interfaces will support delegation as specified by this standard. 

Furthermore, a clear specification and reference implementation for a public delegation standard allows third party tools like wallets to rapidly implement Aion stake-delegation in their products, to further amplify the accessibility of participating in staking as an Aion coin holder. 
    
\paragraph{Custom Delegation Protocols}
Since the public delegation protocol (ADS) is just another contract, leveraging the API exposed by the staker registry contract, one can theoretically construct any on-chain stake delegation protocol, build tools to support it, etc. 

\subsubsection{Other Stake Interactions} \label{staker_reg_interactions}

In addition to enabling the construction of stake delegation contracts, the Staker Registry enables a few obvious (and non-obvious) stake-related interactions:

\paragraph{Private Staking}
For technically inclined users interested in running the equivalent of PoW's \textit{solo-miner}, they can simply sign up to be stakers in the Staker Registry, bond their coins to themselves and run an Aion-Unity node to produce PoS blocks when \say{selected} by the algorithm. 

A very simple CLI will be shipped as part of the Aion-Unity upgrade to easily enable private staking capabilities. 

\paragraph{Direct Delegation}
The design of the Staker Registry enables any user with coins to \textit{vote} for any active staker in the staker registry which enables:
\begin{itemize}
    \item \textbf{\textit{Off-chain Stake Pools}}: Users who do not wish to use the on-chain delegation functionality, can come to agreements off-chain about fees and rewards splitting with some registered staker, and bond their stake directly to them in the Staker Registry. When the bonded staker gets compensated for PoS participation via block rewards, they would presumably split the rewards with the users (off-chain), based on the staking power contributed to the staker by the user. 
    
    \item \textbf{\textit{Naked Staking}}: A user can (inadvertently or deliberately) bond their coins to another user with whom they have no out-of-band agreement on rewards splitting. In such scenarios (since there is no built-in mechanism for rewards splitting in the Staker Registry), the staker in question is not obligated to share any marginal block rewards earned by an increased PoS power vis-Ã -vis the \say{directly} bonded tokens. Note that at no point is a user at risk of loosing their coins, only loss of PoS rewards which one could have received if one staked via private staking or delegation. 
\end{itemize}

\subsubsection{Stake-Delegation User Interfaces}
Very specific guidance and requirements are laid out in this document with respect to the responsibilities of any user interface (UI) for the Aion Public Delegation Standard (ADS). The specifications are requirements for what the UI must achieve, but no guidance is provided as to how to achieve it, to allow flexibility based on the medium (desktop, web, mobile), target audience, etc. 

\subsection{System-Level Requirements}

The following are key functional, non-functional and security requirements for the Staker Registry and Public Delegation Registry (ADS) contracts in Aion-Unity:

\subsubsection{Staker Registry Contract}
\begin{itemize}
    \item \textbf{Pseudo non-custodialness}: Technically, the term non-custodial in the context of PoS refers to systems where the coins never leave the user's account while the user is participating in staking, letting the user move those coins without restriction. Due to the design of Unity consensus \cite{WZS19}, restrictions on a staker's coins must be imposed (such as immobility and post-active period) to satisfy consensus security requirements. To reduce implementation complexity \cite{ZZW19}, the user must send their coins to the staking contract. This requirement states that any coins sent to the staking contract cannot be withdrawn by anyone other than the staker (i.e. the coins cannot be withdrawn by any attacker looking to abuse the contract).
    \item \textbf{Post-active period enforcement}: There must exist no code-path to unstake coins without the coins going through a post-active period. 
    \item \textbf{Sovereignty over stake}: When delegating coins, the staker must not be able to affect the stake in any way (e.g. unstake, restake, etc.) 
    \item \textbf{Auditability of delegation}: All delegations must be publically visible on-chain. 
    \item \textbf{Low-penalty re-delegation}: Users should be able to re-delegate from one pool to another via an on-chain transaction, with minimal time-lock costs.
    \item \textbf{Mitigate key exposure}: The node run by staking pools will need to have some key that is used to sign produced blocks. In case of an incident where the node is compromised, it should be possible for the stake pool operator to revoke this key and replace it with a new one. This should not require any action from the delegator. 
    \item \textbf{Space and time complexity}: All new rules must be computable within \textit{reasonable} space and time complexity. 
    \item \textbf{Minimize economic attacks}: An economic attack arises where the costs incurred by the operators are not covered by the fees on the users of the system. Such situations allow users to impose costs on operators without paying the full costs themselves.
\end{itemize}

\subsubsection{Public Delegation Registry}
\begin{itemize}
    \item \textbf{Sybil attack protection at the staking pool level}: An adversary can take over the network by registering a large number of stake pools, hoping to accumulate enough stake to mount an attack just by people randomly delegating to them. This attack should be made unfeasible by requiring stake pool operators to allocate a finite resource to each individual pool they register; this cannot be the cost of running a node.
    \item \textbf{Handle inactive stake pools}: Stake pools can cease to operate (lost keys, interest, etc.); we want to minimize the effect of this to the security and liveness of the system. 
    \item \textbf{Space and time complexity}: All new rules must be computable within \textit{reasonable} space and time complexity. 
\end{itemize}

\subsection{Coin Lifecycle} \label{stake_concerns}

Figure \ref{fig:stake_lifecycle} outlines the \textit{states} that a coin be in, as it makes it's way through bonding and delegation life-cycles (across the ADS and Staker Registry contracts): 

\begin{itemize}
    \item \textbf{\textit{Liquid}}: A coin is liquid when it is owned by the user's account. In this state, the user is free to transact in the system (e.g. transfer to another user, stake, pay transaction fee for smart contract interactions, etc.).
    \item \textbf{\textit{Staked}}: A coin is staked if is has been cast as a \say{vote} (\S\ref{sc_design} to a staker in the Staker Registry. 
    \item \textbf{\textit{Transfer-pending}}: Stake can be transferred from one staker to another in the staker registry. When this action occurs, the coin must be locked for some short period (transfer-pending period) in order to not violate security invariants of the Unity consensus. The transfer lockout period is required to defend against the following attack vector. Consider a staker who has registered $N$ stake pool. If the transfer of stake was instantaneous, then for all $N$ pools, the staker could compute various PoS \say{time-to-next-block} deltas with different stake distributions, and select the distribution that maximizes their probability of winning the next block (assuming they win the current block).  
    \item \textbf{\textit{Thawing}}: Any time a coin has been staked (either through the staking contract or the delegation interface), a thawing period must be applied to preserve Unity consensus security invariants \cite{WZS19}. After the thawing period (defined in some number of blocks elapsed since the unstaking action) has elapsed, the coins go into the liquid state (i.e. get returned to the user's account). 
    \item \textbf{\textit{Rewards-outstanding}}: When block rewards are distributed by the coin minting function in the protocol, the rewards get paid out to the pool-operator ADS contract. The ADS contract contains logic, upon receipt of rewards, to extract the operator fee from the block rewards and distribute it among the stakers, proportional to their delegated stake. The total reward sum is computed by the contract, with the contract tracking the fraction of the reward each of the parties (delegators, operators) are owed. There are several claims mechanisms available to all parties. After some amount of rewards have accumulated, one can send a transaction to withdraw the coins to their account (liquid). One can also send a transaction to manually re-delegate the rewards-outstanding coins to increase the total stake delegated. Lastly, one can enable the auto-re-delegation feature, which allows the rewards to be automatically re-delegated upon payout. 
\end{itemize}

\begin{figure}[h]
\centering
\tikzset{elliptic state/.style={draw,ellipse}}
\begin{center}
\begin{tikzpicture}[->,>=stealth',auto,node distance=5cm,transform shape]
  \node[initial,elliptic state] (A) {$liquid$};
  \node[elliptic state, align=center] (B) [right of=A] {$staked$};
  \node[elliptic state] (D) [right of=B] {$thawing$};
  \node[elliptic state, align=center, node distance=5cm] (E) [below of=A] {$rewards$\\$outstanding$};
  \node[elliptic state, align=center, node distance=3.5cm] (F) [above of=B] {$transfer$\\$pending$};
  \path (A) edge [align=center,above] node {vote} (B)
        (B) edge [above] node {unvote} (D)
        (B) edge [align=right, bend left=30, left]  node {transfer\\delegation} (F)
        (F) edge [align=right, bend left=30, right]  node {> transfer\\lockout} (B)
        (F) edge [loop left, align=right] node {$<$ transfer\\lockout} (F)
        (D) edge [loop right,align=left,right] node {$<$ unstake\\lockout} (D)
        (D) edge [align=right,bend left=50, pos=0.25]  node {$>$ unstake lockout} (A)
        (E) edge [align=right, bend left=20, pos=0.25]  node {withdraw} (A)
        (E) edge [align=right, bend right=30, right, pos=0.2]  node {auto\\re-delegate} (B)
        (E) edge [align=right, bend left=30, right, pos=0.2]  node {manual\\re-delegate} (B);
\end{tikzpicture}
\end{center}
\caption{States that a coin can be in within the skating and ADS system}
\label{fig:stake_lifecycle}
\end{figure}

\subsection{Delegator Actions}
The following are the actions that an Aion coin holder, seeking to delegate staking rights, can perform with respect to the Public Delegation Registry contract: 
\begin{itemize}
    \item \textbf{Stake Management}
    \begin{itemize}
        \item \textit{\textbf{Delegate stake}}: When the user delegates to a pool, they invoke a function in the staking contract, with the cold address of the staking pool as a transaction parameter. In addition, they need to select whether or not they want to enable the \textit{auto-re-delegation} feature, which will automatically move their stake into the delegated state (i.e. stake will not accumulate in the rewards-pending state, and any withdrawals will be subject to an unbonding period). As part of this transaction, the user will send the amount of coin they would like to delegate-stake. Note that there is a minimum amount requirement (in number of coins) for delegations (see \S\ref{min_delegation} for rationale). 
        \item \textit{\textbf{Undelegate stake}}: When a user decides that they want to withdraw any fraction of their funds from the staking service, they can perform an unstake (or more specifically un-delegate) action in the staking contract. For a period of time measured in number of blocks since the unstaking action, the coin will be in the thawing state; it will be held in the staking contract, but will neither contribute to stake securing the system, nor will it be liquid until the unbonding period has elapsed (see \cite{WZS19} for details).
        \item \textit{\textbf{Transfer-delegation}}: The user should be able to, without triggering the unbonding period, transfer the delegation of any proportion of their stake to another staking pool.
    \end{itemize}
    \item \textbf{Auto-re-delegation}: 
    \begin{itemize}
        \item \textit{\textbf{Opt-in auto-re-delegation}}: If the user did not opt into the auto-re-delegation scheme, they can do so at any time while their stake is delegated, by sending a transaction to the delegation contract. 
        \item \textit{\textbf{Opt-out auto-re-delegation}}: If the user chooses to opt-out of the auto-re-delegation scheme, they can do so at any time while their stake is delegated, by sending a transaction to the delegation contract.  
    \end{itemize}
    \item \textbf{Rewards management}: 
    \begin{itemize}
        \item \textit{\textbf{View rewards}}: The user should be able to publicly view all accumulated rewards, including all rewards distribution events, given any delegator-address.  
        \item \textit{\textbf{Withdraw rewards}}: The user can choose to withdraw accumulated rewards to their address. No unbonding period is applied to this amount; as-soon-as the withdraw transfer is committed on-chain, the user should be able to see the liquid balance in their account. 
        \item \textit{\textbf{Re-delegate rewards}}: The user can manually re-delegate their stake, to increase the total amount of bonded stake they have committed in the system.   
    \end{itemize}
\end{itemize}

\subsection{Stake Pool Lifecycle} \label{pool_lifecycle}

The staking pool life-cycle is very simple, as depicted in Figure \ref{fig:pool_lifecycle}. A staking pool can either be in the \textit{active} state or the \textbf{\textit{broken}} state. If the staking pool in the active state, it implies it is eligible to receive delegated stake and fulfill all responsibilities of a pool-operator within the protocol. The pool starts in the \textit{broken} state and remains so until the pool has been successfully initialized. Furthermore, if any of the pool invariants are violated (see \S\ref{sc_design}), the pool is set to the broken state. If the pool is in the broken state, no new delegations can be made to this pool. Note that any coins still delegated to a broken pool will still be effective as stake in the system until undelegated or transferred.  

\begin{figure}[ht]
\centering
\tikzset{elliptic state/.style={draw,ellipse}}
\begin{center}
\begin{tikzpicture}[->,>=stealth',auto,transform shape,initial text={register pool}]
  \node[initial,elliptic state] (A) {$broken$};
  \node[elliptic state,node distance=6cm] (B) [right of=A] {$active$};
  
  \path (B) edge [align=center,loop above] node {management\\functions} (A)
        
        (A) edge [align=center, bend left=30] node {satisfy pool\\invariants} (B)
        (B) edge [align=center, bend left=30] node {violate pool\\invariants} (A);
\end{tikzpicture}
\end{center}
\caption{Staking pool life-cycle}
\label{fig:pool_lifecycle}
\end{figure}

\subsection{Pool Operator Actions} \label{pool_actions}

The following actions can be performed by the staking pool operator during the course of the life-cycle of the staking pool: 
\begin{itemize}
    \item \textbf{\textit{Register}}: To facilitate easy discovery of stake pool by users of the system, as part of pool initialization, every pool must register with the \textit{(ADS Public Pool Registry}. This registry will contain a list of all active pools. The registering pool must provide the following data: 
    \begin{itemize}
        \item \textit{Fee charged}: A number between 0\%-100\%, which indicates the fees the pool charges for provided service. See \S\ref{sc_design} for details on how this number is applied to block rewards and fees are distributed to pool operators. 
        \item \textit{Metadata URL}: The pool operator must host a JSON file at this URL (HTTPS over TLS), containing the metadata that is displayed in ADS user interfaces (\S\ref{ads_ui}). See the section on the metadata protcol (\S\ref{metadata_protocol}) for requirements on what this JSON object should contain and other ancillary concerns. 
        \item \textit{Metadata content-hash}: This is the Blake2b hash of the JSON object hosted at the metadata URL. This is used as an on-chain commitment of the data hosted at the metadata URL. See \S\ref{metadata_protocol} for details on the function of this content-hash within the metadata protocol. 
        \item \textit{Coinbase address}: This is the public key that receives any fees collected by the pool operator (see \S\ref{key_management} on the key-management scheme in the ADS). 
        \item \textit{(Block) Signing address}: This is the address corresponding to the secret key that the pool operator will use to sign the blocks produced (see \S\ref{key_management} on the key-management scheme in the ADS). 
    \end{itemize}
    
    Before registering with the Pool Registry, the pool operator must first register as a staker in the Staker Registry. When signing-up in the Staker Registry, the pool operator must bond some minimum coin amount (see \S\ref{self_bond} for details). Furthermore, the pool operator must maintain an adequate ratio of stake contributions to self-bonded stake (see \S\ref{self_bond} on self bond requirements for details).
    
    \item \textbf{\textit{Tear-down}}: No graceful pool tear-down functionality has been built into the Pool Registry, to simplify the state-space of the contract. Instead, in a pool operator no longer wishes to a operate a pool, they can instead violate any of the pool invariants described in \S\ref{sc_design} to put the pool into a \textit{broken} state. 
    
    \item \textbf{Management functions}:
    \begin{itemize}
        \item \textbf{\textit{Change fee}}: The pool operator is allowed to change the fee charged for operating the pool, due to market conditions, etc. Note that the fee change takes effect immediately (as soon as the fee-change message is received by the contract by the pool operator). Upon fee-change, delegators take appropriate measures (e.g. stay delegated to the pool, transfer their delegation to another pool, etc.).
        \item \textbf{\textit{Update meta-data}}: The pool operator is allowed to change the metadata of shown in the wallet by updating the content hash and/or the metadata URL. Since the metadata only contains display information about pool, this feature can be used by pools to communicate updates and announcements to the delegators. 
        \item \textbf{\textit{Update bonded-stake}}: The pool operator can send or withdraw bonded coins towards satisfaction of self-bond requirements (see \S\ref{self_bond} for details). 
        \item \textbf{\textit{Update block-signing address}}: If the pool operator suspects their block-signing key is compromised, they can update that \say{hot} key (see \S\ref{key_management} for details). 
        \item \textbf{\textit{Update coinbase address}}: Pool operator can change the address where their rewards are accumulating (see \S\ref{key_management} for details). 
    \end{itemize}
\end{itemize}

\subsection{Operational Requirements} \label{operator_requirements}
Since the pool operator is the entity that gets delegated staking rights from users of the system, the pool operator's primary obligation with respect to the ADS protocol is to run a Aion-Unity full node, that is well connected to the blockchain network, in order to participate in the staking protocol as a block producer. In order to satisfactorily fulfill this obligation, the operator must run computer hardware with comparable or better specifications than:
\begin{itemize}
    \item Intel i7 (Skylake, 6th generation) processor with 4 cores, 8 threads.
    \item 16 GB of DDR4 RAM 
    \item 512 GB SATA SSD
    \item 50Mbps dedicated internet connection  
\end{itemize}
The operator is required to keep at-least 99.9\% (\say{three nines}) availability, which corresponds to at-most 8.77 hours of down-time per year. Pool operators are encouraged to host a web page, advertising self-reported up-times and hardware specification, among other pertinent information about pool operations, to instill confidence in and advertise the operator's operational capabilities. 

\subsection{Key Management} \label{key_management}
The Staker Registry disperses system-responsibilities over several asymmetric key-pairs, to carefully refine the security requirements on each key, which is standard practice in industry.

\paragraph{User symmetric-key rights} This key entitles it's holder the rights to transfer any coins available in the account associated with this key, as well as the rights to delegate and undelegate the owned coins' staking rights. This key should be secured via means of a hardware security module (e.g. Ledger, Trezor, etc.), with appropriate backup protocols in place. If this key is compromised, any delegated stake can be undelegated by the attacker, and then subsequently transferred to another account that the user does not control (after the thawing period has elapsed). 

The user stake is protected by a \say{layer of indirection} designed into the ADS. Coin delegation, undelegation and transfer of delegation rights can only be performed by the user's personal symmetric key (no other entity, including the staking pool operator can retrieve the user's coins while delegated). Therefore, the only way a user's coin can be compromised is if this secret key is leaked.  
    
\paragraph{Pool operator symmetric-key rights} The pool operator is required to manages three keys, each of which corresponds to a distinct function in the operation of the pool: 
\begin{itemize}
    \item \textit{Coinbase address}: PoS block rewards get paid out to this key. If this address corresponds to a smart contract (e.g. ADS), then this contract must be secured from known attacks on contract balances. If this address is a user account, the receiver of the rewards must secure this account appropriately.  
    \item \textit{Block-signing key (hot key)}: This key entitles it's holder the rights to produce blocks on behalf of ala stake delegated to the staker. This key needs to be kept online while connected to the Aion-Unity network, since this key is required to sign any blocks won by the staker in the course of the PoS \say{lottery}. At the moment, the guidance is to load this private key in the memory of an appropriately permissioned process, or in a commercial HSM (e.g. YubikeyHSM 2) that supports EdDSA (ED25519) signatures. If this key is compromised, the attacker can censor (deny inclusion of) transactions within the blocks supported by the delegated stake. 
    \item \textit{Management key (cold key)} This key entitles it's holder the rights to all pool management tasks \S\ref{pool_actions}. This key should be kept in cold storage (HSM) at all times, and only be retrieved when management tasks need to be performed. There is no mechanism to replace this key with another one, since this (public) key is the identity of this pool; this public key is used by any entities addressing this pool for any on chain interactions with this pool (e.g. delegators use this public key to identify the pool they would wish to delegate their staking rights to). This is the key used by the operator to register the pool. If this key is compromised, the pool is compromised and must be shut down. If this key is compromised, the attacker can take over pool operations (e.g. shut-down the pool, etc.). It is important to note that even if this \say{master pool key} is compromised, the delegated stake is in no risk; to reiterate, no key, except for the user's very own, has rights to alter any votes or withdraw any bonded coins. In the event of a management key compromise, the user must simply transfer delegation rights to another pool with sufficient delegation capacity to resume any interruptions in rewards outlays. 
\end{itemize}

Note that when registering for a pool (\S\ref{pool_actions}), do not use exchange addresses for the rewards key or the block-signing keys. The operator needs to control the private key for the rewards account in order to (send a transaction and) retrieve the rewarded coins, which accumulate in the delegation contract. Needless to say, the operator needs to control the private key for the block-signing account in order to sign the blocks on their full node.   

\subsection{Metadata Protocol} \label{metadata_protocol}
When an operator registers a new staking pool in the delegation contract (ADS), the new pool gets added to an on-chain registry of all active staking pools. During registration, the pool operator is required to provide metadata about the pool (e.g. logo, web-page, human-readable name, etc.). This metadata could then be consumed by user interface enabling stake delegation in Aion-Unity. 

We define an explicit protocol for metadata management, which involves both on-chain and off-chain actions. This protocol standardizes the way any user interfaces enabling delegation on Aion-Unity can retrieve rich data about staking pools, which empowers both pool operators and delegators: 
\begin{itemize}
    \item The pool operators have a transparent and easy process to maintain rich contextual descriptors about their staking pools, which automatically get pulled int, and updated across all user interfaces implementing the ADS. Without such standardization, staking pools would have to manage relationships with all relevant ADS front-end providers in order to get listed and service contextual-information requirements (e.g. logo, pool descriptions, etc.) 
    \item The delegators can rely on a rich set of descriptors provided by the pool operators, widely available across all user interfaces implementing the ADS, providing meaningful data points to inform their delegation decisions.   
\end{itemize}

When a staking pool registers to the ADS, the pool operator must provide a \textit{metadata URL} and the \textit{metadata content-hash}. The pool operator must host a JSON file at the metadata URL (HTTPS over TLS), with the following schema: 
\begin{itemize}[label=--,nosep]
    \item \textit{\textbf{Schema version}}: A version number, to identify the schema. This is here to enable upgradability. 
    \item \textit{\textbf{Logo}}: A thumbnail containing the logo of the pool. The image must be base64 encoded PNG, with the dimensions of 256 pixels-square.
    \item \textit{\textbf{Description}}: A \say{tell me about yourself}-style, short description for users to consume when making stake delegation decisions. This field shall not exceed 256 characters.
    \item \textit{\textbf{Name}}: A human-readable name for the pool. This field shall not exceed 64 characters.
    \item \textit{\textbf{Tags}}: These serve as keywords for any search functionality to be exposed by any ADS user interface. This is a JSON array. The size of this array shall not exceed 10 elements, with each element not exceeding 35 (valid) characters.
    \item \textit{\textbf{Pool URL}}: This is a URL, pointing interested delegators to the homepage of the pool, for additional information to peruse, in order to help make their delegation management decisions. 
\end{itemize}

The JSON must be valid according to the RFC 7159 JSON specification \cite{rfc7159}. The hash of the JSON object must match the content hash provided. The document must be less than $1024\times1024$ bytes (1 mb). All characters must be UTF8 encoded. The document hosting service must guarantee three nines availability (99.9\% uptime). The Blake2b hash of the JSON object must match the content hash provided on-chain. 

We further propose the use of \textit{proxy servers} to cache the list of staking pools and their associated metadata. This enables rapid implementation of ADS user interfaces, since one could query a web-service to retrieve this list, as opposed to querying each metadata URL in the staking pool registry. The implementation of this server is very simple:
\begin{itemize}
    \item \textit{Pool metadata caching}: When an operator updates the metadata hosted at the metadata URL, they must also update the metadata content hash on-chain. The proxy server polls the pool registry, listening for changes in content hash. When the content hash changes, the cache is invalidated and the new metadata is loaded into the cache. 
    \item \textit{Security screening}: The proxy server shall implement rules to filter out malicious content in the metadata. As attackers evolve mechanisms to attack the user interfaces, this simple server can be adaptively updated quickly in response. 
\end{itemize}

To address concerns around centralization and censorship of pool lists by the proxy server, we will open-source the proxy server implementation and encourage community participants to run these proxy servers. Furthermore, we require any ADS user interface to be configurable to query a number of these proxy servers.

\paragraph{Alternative approaches} An alternative approach considered for the design of the metadata protocol was to implement the pool registry off-chain. There were centralization risks associated with this approach, namely the censorship by registry-maintainers of pools on this list (either by omission or manipulation of rankings). 

Another approach that was considered was storing the metadata directly on-chain (and doing away with the metadata-URL and proxy server scheme). This strategy was not selected due to flexibility concerns. The metadata is a field primarily used by pool operators as an advertisement avenue; this schema can conceivably be required to adopt additional fields to improve richness of pool metadata. In addition, this scheme allows for the metadata to become much larger than currently specified, without concerns of block size restrictions or on-chain data bloat. 

Although this operator-hosted metadata scheme increases the implementation complexity slightly on part of the pool operators, it opens-up the opportunity to improve the quality of service of the ADS user interfaces in the future. 

\subsection{Rewards-splitting Scheme} \label{rewards_splitting}

Rewards sharing in the ADS is an automatic process that does not require any action on part of the stake pools. For each block that a pool \say{wins}, the block rewards are split between the operator and the delegators using the following scheme: first the operator fee is deducted from the block rewards, then the remaining balance is split between the delegators, weighted by their respective stakes pledged to the pool.

For example, if the block reward is 5 coins, the pool fees are 20\% and there are three delegators, whose pledges account for 50\%, 37.5\% and 12.5\% of the pools total stake respectively. Then the rewards distribution (for that block) will look like the following: 
\begin{itemize}[label=--,nosep]
    \item Operator rewarded 1 coin (20\% of 5 coins)
    \item Delegator \#1 gets 2 coins (50\% of the remaining 4 coins, after deducting operator fees)
    \item Delegator \#2 gets 1.5 coins (37.5\% of the remaining 4 coins, after deducting operator fees)
    \item Delegator \#3 gets 0.5 coins (12.5\% of the remaining 4 coins, after deducting operator fees)
\end{itemize}

There are several mechanisms available to the operator and delegator to claims rewards from the Pool Registry contract: 
\begin{itemize}[label=--,nosep]
    \item After some amount of rewards have accumulated, one can send a withdraw transaction to the ADS contract from the appropriate account (rewards account for the pool operator, coin-owning account for the delegator) to retrieve their coins as \say{liquid balance}. 
    \item One can also manually re-delegate the rewards-pending coins to increase the total stake delegated. 
    \item Lastly, one can enable the auto-re-delegation feature, which allows the rewards to be automatically re-delegated upon payout (rewards do not accumulate in the rewards-pending state in this scenario). 
\end{itemize}

\subsection{Self-bond Requirements} \label{self_bond}
We propose imposing a self-bond requirement on all stakers registered in the Staker Registry. If the self-bond goes below the prescribed minimum, then all stake bonded to the staker becomes ineffective (i.e. loss of influence in PoS). There are two major reasons to implement such a scheme.

First, this creates a minimum cost (outside of the cost to run computer hardware) for someone to become a staker. This adds a barrier for anyone looking to launch a sybil attack (a single stakeholder creating a large number of pools in the hopes of dominating PoS voting power by means of random delegators choosing their pool). 
 
Second, this facilitates the implementation of a slashing mechanism to punish any misbehaviour (protocol deviation) on part of the pool operator (see \S\ref{slashing}. If there were no self bond requirement, the pool operator has no \say{skin in the game}, and could behave maliciously (w.r.t the protocol) with impunity. 

\subsection{Restricting Pool Size (Optional)}
Designing incentive mechanisms that promote decentralization in PoS delegation protocols is an open problem. PoW has a tendency to centralize via the creation of mining pools; in the Bitcoin network, mining pools have been observed to control over 50\% of network hash-rate on occasion \cite{RJZ+19}. The design of a public stake-delegation protocol (ADS) for Aion-Unity requires mechanisms to incentivize decentralized behaviour, to avoid some of the pitfalls PoW mining pools have encountered. 

The challenge that lies at the heart of such a design is the inherent trade-off between efficiency and decentralization: 
\begin{itemize}[label=--,nosep]
    \item \textit{Efficiency} is optimized if only one pool operator exists that all stakeholders delegate to. This would minimize the operational costs of the network (since all the stake is delegated to one node, which would be the only PoS node operating on the network); this would in-turn maximize profits for all stakeholders. 
    \item \textit{Decentralization} is maximized if every single stakeholder runs their own node to contribute to PoS network security. Note that the PoS subsystem in Unity was designed to boost this kind of maximally-decentralized network configuration. 
\end{itemize}

Operation of the PoS network in either of the aforementioned regimes is neither desirable, nor realistic (today). Therefore, an incentive-based mechanism needs to designed to find a balanced solution, such that some large number of pools with uniformly distributed stake-delegations can be encouraged. 

Brunjes et al. propose a rewards-distribution function such that some target number of stake pools can be achieved (proof for a Nash equilibrium arising from rational play for such a condition is provided) \cite{BKK+18}. Although promising, further analysis is required to adapt this rewards mechanism to Unity consensus, and may be considered in an upcoming update. 

Instead, the following simple scheme (inspired by Tezos \cite{Goo14}) is proposed. It involves imposing a self-bond requirement on staker, which proportionally determines the limit on the stake that can be delegated to the pool. Consider an example: assume that the self-bond requirement is 2\% and the minimum self-bond requirement is 100 coins. If the pool-operator has self bonded 1000 coins, then the maximum stake that can be delegated to this pool is $50,000$ coins.   

This creates a restriction the the size of the pools, to discourage the formation of very large pools (since the pool operator would have to put a large amount of self bonded stake in order to operate a pool with large contribution margins. Note that the pool cannot be over-delegated. Any operation that delegates more stake to a pool than allowed by the self-bond-to-delegation-capacity ratio, will fail. 

Although this scheme does not provably deter centralization, it produces some barriers to sybil attacks and pools becoming too large, while enabling a large number of honest pools to operate in the PoS ecosystem.  

\subsection{System Parameter Summary} \label{unspecified_parameters}
The following is a summary of the system in the Aion-Unity implementation \textcolor{red}{which are yet to be defined}: 
\begin{itemize}
    \item \textit{Self-bond minimum}: This refers to the minimum amount of bond required to be \say{put up} by the staker. See \S\ref{self_bond} for details.
    \item \textit{Post-active (thawing) period}: This refers to the time (in blocks) that stake is immobile and ineffective (w.r.t. PoS staking) after a staker has initiated a stake withdrawal (either via an undelegation or unstake operation). See \S\ref{stake_concerns} for details. 
    \item \textit{Transfer lockout period}: This refers to the time (in blocks) that stake is immobile and ineffective (w.r.t. PoS staking) after a staker has initiated a stake transfer to another staker. See \S\ref{stake_concerns} for details. 
    \item \textit{Staking (per-block) rewards}: This refers to the computation of the total per-block rewards disbursed to the proposer of a PoS block. This mechanism will be discussed in an upcoming section of this paper. 
\end{itemize}

\subsection{User Interface Concerns} \label{ads_ui}
In the following section, we don't define any implementation guidelines; but rather we specify some key features that the user interface must employ in the implementation of the public delegation system (ADS). 

\subsubsection{Pool Registry Presentation} \label{registry_presentation}
The user interface shall produce a list of all active and retired pools in the stake pool registry. For each pool any pertinent information required by the user in order to make delegation decisions should be presented (e.g. fee, capacity remaining, rewards estimates, etc.). The user should be able to delegate to multiple pools and view all their outstanding delegations and rewards earned from each delegation (at the block-level resolution). 

The user interface can retrieve the pool registry and associated metadata from the metadata-proxy server (as defined in \S\ref{metadata_protocol}). If the metadata is malformed (i.e. any of the metadata rules defined in \S\ref{metadata_protocol} are violated), the metadata will be unavailable on the proxy servers; UI should be designed to handle such scenarios. Furthermore, the UI should be configurable to query a number of metadata-proxy servers to promote diversity in metadata-proxy server providers. 

In order to help users make a rational decisions with respect to their stake delegations, we propose that the pool registry listing should be default-sorted using some weighted function of:  
\begin{itemize}[label=--,nosep]
    \item the fees charged by the pool, 
    \item the apparent performance of the pool (see \S\ref{apparent_perf}), and
    \item the remaining contribution capacity.
\end{itemize}
The goal of this proposed \say{attractiveness score} is to promote pools that are reliable, have not yet reached saturation, and have a low cost. \textcolor{red}{Further research is required to specify this function precisely.}  

\subsubsection{Calculating Apparent Performance of Pools} \label{apparent_perf}

The wallets should report some notion of up-time for a pool; this measure is critical to gauging the reliability of a pool, and directly impacts the rewards a delegator can expect to receive by delegating to this pool (delegators should rationally choose pools with the highest possible historical up-times, since even if a pool offers low fees, a spotty up-time track-record will manifest itself in diminished rewards). 

Since there is no explicit way to capture an up-time metric in the design of Aion-Unity PoS (due to it's stochastic nature), we instead propose a simple solution to find a proxy for the \say{onlineness} of the pool operator that we are calling \textit{apparent performance}. 

A pool is considered \textit{established} if it has been active for at-least 1 week (~$60,480$ blocks). For any established pool with sufficient size (in terms of delegated stake), we can effectively infer some notion of up-time. The reason that an inference is the best we can do is because the stake amount can fluctuate over time and the rewards are unpredictable (distributed stochastically) at every block, with no protocol-defined mechanism to measure \say{onlineness} of a pool operator. The apparent performance measure can be constructed as follows: 
\begin{itemize}[label=--,nosep]
    \item First, we define a moving window of $60,480$ blocks (~1 week) over which we define the following averaged metrics.
    \item Since the stake amount can fluctuate over time, to get a stable measure for the amount of stake delegated to a pool over a period of time, we take some average (either over the complete interval or with gaps) of the active stake delegated to a pool over the last 1 week's worth of blocks.
    \item Then perform a similar calculation as above, except over the stake delegated to all the pools, to get an average for the total stake delegated to the system over the last week.
    \item With these two averages in hand, we can determine the expected ratio of blocks this pool should have produced in proportion to the total blocks produced over the last week. 
    \item Finally, we need to find the ratio of the expected blocks produced over the last week to the actual blocks produced, which will give us some measure of apparent performance (a number between 0 and 1).  
\end{itemize}

There are several factors that could skew this calculation. First of all, the notional 1 week might not be a long enough time over which to compute these averages. Furthermore, large swings in stake contributions could skew the computation of the arithmetic mean; this may potentially be fixed by sizing the window as a function of the standard deviation of the time-series function of stake contribution magnitudes. 

When a new pool is created, there is no data to determine it's apparent performance. New pools should be distinguished from the established pool (e.g. displayed in a separate section of the UI), since no reasonable measure for future performance can be inferred. 

\subsubsection{Pool Life-cycle Notifications}
The UI is responsible to produce notifications for all key life-cycle events for the pools a user has delegated staking rights to, to enable a user to make appropriate delegation decisions. 

\paragraph{Management Actions}
The UI must notify a user when a pool goes into the \textit{broken} stake and changes it's fees (\S\ref{pool_actions}). Any \textit{broken} pools must be clearly identified. The user should be able to transfer any delegations from a \textit{broken}  pool to an active pool at any time. 

\paragraph{Inactive and Underperforming Pools}
The should monitor the attractiveness score (\S\ref{registry_presentation}) of all the pools the user has delegated stake to, in order to notify the user of any significant drops in this metric. Particularly, any significant drops in this metric implies one or more of the following things: 
\begin{itemize}[label=--,nosep]
    \item A large amount of stake has left the pool.
    \item The pool's average up-time has dropped significantly (operator has stopped producing blocks). 
    \item The pool operator has hiked up the fee significantly. 
    \item The rewards earned by the user have diminished significantly. 
\end{itemize}

This way, if the pool ceases to operate without being properly retired, it's delegators will be incentivized to re-delegate. 


\subsection{Smart Contract Design} \label{sc_design}
Here, we outline the design of the smart contract implementation of the staking and delegation system in Aion-Unity. The system consists of three distinct contracts (with their relationship depicted in Figure \ref{fig:contract_arch}):

\begin{figure}[ht]
\centering
\begin{tikzpicture}[auto,>=latex']
    \node [block, name=sr, align=center, minimum width=3cm] (sr) {Staker Registry\\Contract};
    \node [block, right of=sr, node distance=5cm, align=center, minimum width=3cm] (pr) {Pool Registry\\Contract};
    \node [block, right of=pr, node distance=6cm, align=center, minimum width=3.6cm] (pc1) {Pool 1\\Coinbase Contract};
    \node [block, above of=pc1, node distance=1.8cm, align=center, minimum width=3.6cm] (pc0) {Pool 0\\Coinbase Contract};
    \node [block, below of=pc1, node distance=2.8cm, align=center, dashed, minimum width=3.6cm] (pc2) {Pool N\\Coinbase Contract};
    \draw [<-] (sr) -- node{$calls$} (pr);
    \draw [->] (pr) -- node{} (pc0);
    \draw [->] (pr) -- node{$spawns$} (pc1);
    \draw [->, dashed] (pr) -- node{} (pc2);
    \path (pc1) -- node[auto=false, font=\large, midway, sloped]{\ldots} (pc2);
\end{tikzpicture}
\caption{Smart contract architecture for stake delegation in Aion-Unity}
\label{fig:contract_arch}
\end{figure}

\begin{itemize}
    \item \textbf{\textit{Staker Registry Contract}}: This contract tracks all stake and stakers in the system and is core to the Aion-Unity protocol (i.e. this is a privileged contract, whose state is required by the protocol to resolve PoS consensus). Anyone wishing to cast their coins to stake (including other contracts, e.g. delegation contracts), need to register here. Key indirection (as described in \S\ref{key_management}) is built-in here; when one signs up to be a staker, one needs to provide their coinbase and signing addresses. 
    \item \textbf{\textit{Pool Registry Contract}}: This contract is non-core to the system (i.e. has no special privileges in the system). This is the implementation of the Aion Delegation standard (ADS) and is responsible for: 
    \begin{itemize}[label=--,nosep]
        \item keeping a registry of all staking pools and associated meta-data,
        \item receiving coins (as delegation to a pool) and casting them to stake, 
        \item managing internal state of each pool (including delegation and rewards),
        \item and splitting the rewards among the pool operator and delegators. 
    \end{itemize}
    This contract implements the StakerRegistryListener interface, which enables this contract to be notified about changes made by a pool operator in the StakerRegistry to its signing and coinbase addresses (see \S\ref{pool_states} for details). 
    \item \textbf{\textit{Pool Coinbase Contract}}: This contract is spawned by the pool registry contract for each pool it instantiates. The pool's coinbase contract receives block rewards on behalf of the pool. For a particular pool, when the operator or any of the delegators request a withdrawal (in the PoolRegistry), the coins are withdrawn from this contract by the PoolRegistry. This is an implementation artifact and the end user should never need to understand the function of this contract. It is here to collect rewards. 
    
    We now outline the rationale for this design. Recall that the PoolRegistry has no special privileges. The standard way block rewards are disbursed is by crediting the coinbase account cited in the block header. Since all pools and their states are managed in the PoolRegistry contract, if the block rewards for all pools were paid to the PoolRegistry contract, the contract could not figure out which pool the disbursement was intended for (since no contract code gets executed by the protocol upon block reward outlay). Therefore, the PoolRegistry must spawn and manage a unique contract (per pool) to receive block rewards in the standard way, and then retrieve these rewards from this contract when withdrawals are requested by any delegator or operator.  
\end{itemize}

\subsubsection{Rewards Distribution Algorithm} \label{f1-rewards}

One critical requirement regarding rewards sharing is that \say{rewards sharing must be an on-chain, automatic process that does not require any action on part of the stake pools}. The problem of on-chain rewards distribution appears trivial at first glance, but deserves significant attention care in its design.  

First, lets consider the naive solution to the problem of block rewards distribution. Assume some hypothetical \say{onBlockProduced} function that executes as the last transaction in a PoS block produced by a staking pool. In this function, the block rewards are be disbursed to the pool's operator and delegators. The time-complexity of this function is linear in the number of delegators in the pool. Since the disbursement to each delegator requires at-least one state update (database write), state updates linear in the number of delegators in the pool would need to be performed. Furthermore, since state updates are a fairly costly operation in the Aion-AVM regime, especially for large pools, updating the state for every delegator in a pool alone, could easily surpass the total gas limit of a block (which represents the maximum amount of computation that network participants can perform in the validation of blocks, while keeping the block-time stable). Since the combined gas cost for disbursements and the included transactions in a block cannot exceed the total block gas limit, this naive solution is clearly impractical: consider a \say{full} PoS block; there is no gas budget left (in the block) for rewards disbursement!  

\paragraph{F1 Rewards Distribution} A more clever solution this problem was proposed by Ojha \cite{Ojh19}. A detailed description of the rewards distribution mechanism is out of the scope of this report (please refer to \cite{Ojh19} or a toy-implementation by the author \cite{Sha19}). 

This algorithm moves all rewards distribution computation from some hypothetical \say{onBlockProduced} function (which is not available in the Aion protocol to begin with), to any events where the rewards-per-unit-stake changes (e.g. delegate, undelegate, withdraw, etc.). The rewards distribution is still linear in the number of delegators, but the computation is amortized over the interactions users have with the system (i.e. all fee distribution computations are \say{fuelled by} user-provided gas).   

Furthermore, this algorithm is approximation-free; in the rewards distribution calculations, the only source of approximation is finite decimal precision, which cannot be avoided (confirmed using simulation in \cite{Sha19}).  

\subsubsection{Asynchronous Tasks}
There are several instances of \say{asynchronous} tasks in the Aion-Unity staking and stake delegation systems: 
\begin{itemize}
    \item \textit{\textbf{Unbonding Stake}}: Upon unbonding or undelegating of stake, the coins must be ineffective in PoS and immobile (not liquid) for at-least the thawing period \S\ref{stake_concerns}.  
    \item \textit{\textbf{Transfer Stake}}: Upon transfer of stake from one staker to another in the Staker Registry contract, the coins must be ineffective in PoS and immobile (not liquid) for at-least the transfer-pending period \S\ref{stake_concerns}.  
    \item \textit{\textbf{Auto Redelegation}}: Rewards earned by delegators in the system can be \say{auto-delegated}; i.e. coins earned as part of block rewards can be automatically cast to stake on behalf of the delegator.  
\end{itemize}

These features are asynchronous in the sense that these features cannot be implemented within one transaction initiated by the user; they require some action by the protocol itself (not initiated by a user), after some condition on contract or chain state has been met.   

In the case of unbonding and transfer stake, they are examples of time-locks, which require an action from the system, delayed into the future from some trigger-action. 

On the other hand, auto redelegation (in it's most trivial incarnation) is a case of the protocol taking an action on behalf of the user upon an event (disbursement of rewards). 
No mechanism exists in the protocol for transactions to be scheduled in the future or be automatically triggered if a (chain or contract) state change occurs, since it violates security constraints of the AVM computation metering system. 

Therefore, we had to flatten the aforementioned features into two disparate transactions (an initiating transaction and a finalizing transaction). The initiating transaction is sent by a user looking to affect their state (unbond, transfer or enable auto-redelegation). The finalizing transaction can be performed by anyone in the system (including the user himself) in order to unwind the initiated action.

We considered incentives that people would have to make function calls on other users' behalf. In the case of auto redelegation, we attached a fee that the callers could collect for calling auto redelegation. In the case of the time-lock interactions, we figured the user could call it themselves, or expect their staking pool to perform it (could be included in the fee charged by the pool). 

\paragraph{Unbonding Stake}
Ubonding requires two treansactions: one to undelegate, and a second to unVote when the period has elapsed. Technically at that point, the coins are liquid, so with one transaction, they are immediately available. Alternatively, we could have a public goods system like the redelegateRewards scheme, although, that seems like overkill, since within one transaction, that money comes back to you anyway. This is done so that we don't have add in the onBlockProduced hook. 

\paragraph{Transfer Stake} demonstrates a delegation transfer feature. This is the idea that if I delegated to a pool, I should be able to transfer my delegation to another pool, with minimal overhead. We can't make the transfers instantaneous, as that creates an attack vector in unity (if you can instantaneously transfer, then you can compute the next delta parameter by changing the amount of stake, to preferentially win blocks!). Therefore we need to impose some delay between when you send a transfer delegation request, and when it takes effect. This delay is smaller than the undelegation delay. This transfer is a two step process (just like auto-delegation and private unstake, and undelegation. Unlike auto redelegation, there is no fee for people to finalize transfers since the pools have an incentive to finalize transfers. We recommend the implementation of a batch protocol to make it even more efficient to finalize a whole bunch of transfer in one shot. Furthermore, the user can wait the transfer lockout period and send the finalize transfer transaction themselves. 

\paragraph{Auto Redelegation of Rewards} 
Auto-redelegation of rewards (as introduced in \S\ref{stake_concerns}), is the idea that users can set a variable in the contract that will automatically delegate any rewards the user has accumulated as stake, so the user does not have to constantly redelegate. Since this is not a privileged contract, no hooks exist in the AVM paradigm to automatically trigger logic, therefore, we have to construct a "protocol-within-a-protocol". Effectively, the way this works is the following: when the user opts in to auto-relegation, they are opting into the fact that any user of the system can send a transaction to re-delegate my rewards on my behalf. This means, they could run a script to redelegate their rewards, or sign up on some kind of service that does this for them. Why would anyone run this service? We built in this mechanism of \textbf{\textit{auto-redelegation fee}}, which is a nominal fee that anyone calling this function on your behalf can charge per function call. To not over-complicate the system, this fee will be fixed. The idea is that web-services can be written which scrape which accounts have registered for auto-redelegation and then they wait for enough rewards to accumulate for that account. One the rewards are large enough such that the fee $*$ rewards is greater than the transaction cost by some profit threshold, they will send a transaction on your behalf to redelegate your stake.  

There are two paths into Auto-redelegation. One while delegation, and one to enable after a delegation. If you did not call the function to enable auto redeleagtion upon delegation, you can call an additional function called enable auto redelegation. Either way you enable, you need to provide a fee. This fee gets provided to any user who calls autoRedelegate on your belhaf. Basically, the idea is that due to async nature of the F1 rewards scheme and lack of an onBlock event, autoRedelegation becomes a feature that people might want as they might want to \say{set it and forget it} (i.e. they want their stake to compound automatically. In this design, people are incentivized to send transactions to autoRedlegate rewards for users based on the fee. So for example, if the fee is 2\% for a particular user, people would wait until enough rewards have been accumulated for an account such that 2\% of that value is an appropriate reward for me to send this transaction. Batching service should be provided, to make these transactions even more economical. 








\subsubsection{Pool States: Broken and Active} \label{pool_states}

There are two states in the pool life-cycle (Figure \ref{fig:pool_lifecycle}): \textit{broken} and \textit{active}. If the pool isn't broken, it's active. When is a pool in the \textit{broken} state?
\begin{itemize}
    \item When a pool is registered, a new PoolCoinbase contract is deployed to track block rewards paid out to the pool. The pool starts out in the broken state, and remains so until both of the following conditions are met: the pool registry contract is set as the StakerRegistryListener for this particular pool and the coinbase is set correctly in the StakerRegistry contract. 
    \item If the coinbase address is changed in the staker registry to anything other than the pool coinbase deployed by the PoolRegistry contract on pool initialization, the pool get's broken.There should be no way in the implementation to violate this invariant. 
    \item If the PoolRegistry contract is removed as a listener for this pool, the pool gets broken. There should be no way in the implementation to violate this invariant.
    \item If the pool's self-bond requirement is violated (see \S\ref{self_bond}), the pool gets broken.
\end{itemize}

Currently, there is no implication for a pool to be in a dead state, but in a future release, we can make the pool unable to generate blocks if the pool is in the broken state (pending).

\subsection{Protocol (Kernel) Responsibilities}
Since the function of the protocol depends on the StakerRegistry contract's state, there must be some special interactions that must to coded into protocol implementation (i.e. \say{the kernel}). 

Every time a PoS staker (node operator) produces a block, the kernel must look-up the staker by his signing key (\S\ref{sc_design}) in the StakerRegistry to validate the following:
\begin{itemize}[label=--,nosep]
    \item the claimed time-to-next-block is valid, based on their committed stake in the StakerRegistry,
    \item the claimed coinbase (from the block header) is the registered coinbase in the StakerRegistry,
    \item and the staker is eligible to produce a block at the proposed block height. 
\end{itemize}
